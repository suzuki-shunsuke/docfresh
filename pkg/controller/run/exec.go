package run

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"time"

	"github.com/spf13/afero"
)

const waitDelay = 1000 * time.Hour

func setCancel(cmd *exec.Cmd) {
	cmd.Cancel = func() error {
		return cmd.Process.Signal(os.Interrupt)
	}
	cmd.WaitDelay = waitDelay
}

func (c *Controller) execCommand(ctx context.Context, command *Command) (*TemplateInput, error) {
	shell := command.Shell
	if shell == nil {
		shell = []string{"bash", "-c"}
	}
	cmd := exec.CommandContext(ctx, shell[0], append(shell[1:], command.Command)...) //nolint:gosec
	stdout := &bytes.Buffer{}
	stderr := &bytes.Buffer{}
	combinedOutput := &bytes.Buffer{}
	cmd.Stdout = io.MultiWriter(os.Stdout, stdout, combinedOutput)
	cmd.Stderr = io.MultiWriter(os.Stderr, stderr, combinedOutput)
	setCancel(cmd)
	fmt.Fprintln(os.Stderr, "+", command.Command)
	if err := cmd.Run(); err != nil && !command.IgnoreFail {
		return nil, fmt.Errorf("execute a command: %w", err)
	}
	return &TemplateInput{
		Type:           "command",
		Command:        command.Command,
		Stdout:         stdout.String(),
		Stderr:         stderr.String(),
		CombinedOutput: combinedOutput.String(),
		ExitCode:       cmd.ProcessState.ExitCode(),
	}, nil
}

func (c *Controller) exec(ctx context.Context, file string, input *BlockInput) (*TemplateInput, error) {
	if input.Command != nil {
		return c.execCommand(ctx, input.Command)
	}
	if input.File != nil {
		return c.readFile(file, input.File.Path)
	}
	if input.HTTP != nil {
		return c.request(ctx, input.HTTP.URL)
	}
	return nil, errors.New("no command or file specified")
}

func (c *Controller) readFile(file, p string) (*TemplateInput, error) {
	p = filepath.FromSlash(p)
	if !filepath.IsAbs(p) {
		p = filepath.Join(filepath.Dir(file), p)
	}
	b, err := afero.ReadFile(c.fs, p)
	if err != nil {
		return nil, fmt.Errorf("read file: %w", err)
	}
	return &TemplateInput{
		Type:    "local-file",
		Path:    p,
		Content: string(b),
	}, nil
}

func (c *Controller) request(ctx context.Context, uri string) (*TemplateInput, error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, uri, nil)
	if err != nil {
		return nil, fmt.Errorf("create http request: %w", err)
	}
	resp, err := c.httpClient.Do(req) //nolint:gosec
	if err != nil {
		return nil, fmt.Errorf("send http request: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}
	b, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("read response body: %w", err)
	}
	return &TemplateInput{
		Type:    "http",
		URL:     uri,
		Content: string(b),
	}, nil
}
